= DataQ

DataQ's purpose is simplifying the read/write operations over data build on top of a concatenation of structs.
The idea is allowing to reference struct's fields using a hierarchical fully qualified name.

Below an fictional data structure built on top of a concatenation of a three structs.

[source,golang]
----
type Level3 struct {
	Delta int
}

type Level2 struct {
	Ypsilon int
	Omega   string
	Eplison *Level3
}

type Level1 struct {
	Alfa  float64
	Gamma *Level2
}
----

DataQ allows to reference the above fields using fully qualified names:

* Alfa
* Gamma.Ypsilon
* Gamma.Omega
* Gamma.Epsilon.Delta

== Why DataQ?

The initial idea behind this simple DataQ library is to simplify the usage of data transfer objects, when the source data structure is different from the target one.

A possible scenario is using Govaluate footnote:[https://github.com/Knetic/govaluate] to evaluate arbitrary expressions, where referenced variables come from mashaling a JSON response and the latter is obtained by an external API. Govaluate accepts a __map[string]interface{}__ to get the variables reference by the expressions, thus you may have to build that map extracing data from the potentially complex data structure coming from the API.

Given the previous fictional struct Level1, you may suppose to calculate the mathematical expression: 

[source,math]
----
"Alfa + Gamma_Ypsilon"
----

Note that the separator for the fully qualified name of the field is now "_", in order to avoid conflict with the mathematical syntax.

Using DataQ, the resulting code is:

[source,golang]
----
func Calculate(l1 interface{}) error {
	s := NewSurfer(WithSep("_"))
	expr, err := govaluate.NewEvaluableExpression("Alfa + Gamma_Ypsilon")
	if err != nil {
		return err
	}
	flat_data, err := s.GetFlatData(l1)
	if err != nil {
		return err
	}
	result, err := expr.Evaluate(flat_data)
	if err != nil {
		return err
	}
	log.Print(result)
}
----

== Technical constraints, limitations and documentations

DataQ only handles exported fields of the struct with a limited set of types:

* string
* float64
* int64
* bool

Technical documentation: https://github.com/LosAngeles971/DataQ/blob/main/docs/DataQ.md

== Inspirational references

* https://github.com/Knetic/govaluate
* https://blog.gopheracademy.com/advent-2018/interfaces-and-reflect/
* https://github.com/jinzhu/copier/blob/master/copier.go
* https://code.rocketnine.space/tslocum/godoc-static